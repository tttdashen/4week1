def fact(n):
    if n==1:
        return 1
    return n*fact(n-1)

print(fact(3))
print(fact(10))
"""
如果我们计算fact(5)，可以根据函数定义看到计算过程如下：
=> fact(5)
=> 5 * fact(4)
=> 5 * (4 * fact(3))
=> 5 * (4 * (3 * fact(2)))
=> 5 * (4 * (3 * (2 * fact(1))))
=> 5 * (4 * (3 * (2 * 1)))
=> 5 * (4 * (3 * 2))
=> 5 * (4 * 6)
=> 5 * 24
=> 120
递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，
所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：报错了
"""
"""
普通递归（非尾递归）
例如计算阶乘的普通递归实现为：
def fact(n):
    if n == 1:
        return 1
    return n * fact(n - 1)
执行过程：
当调用 fact(5) 时，程序会先计算 5 * fact(4)；
但在返回前还需要等待 fact(4) 的结果，然后再执行乘法操作；
递归调用结束后，每一层函数调用都必须在返回后保存一个运算状态（例如乘法），这些状态存放在栈帧中。
问题：
当递归层数很深时，每次递归都占用一个栈帧，可能会导致栈溢出。
"""
#尾递归
def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
#这里的 return fact_iter(num - 1, num * product) 是整个函数的最后一步，
# 没有额外的计算操作；因此，这个函数是尾递归函数。

#如何改造普通递归为尾递归
# 为了将普通递归转换成尾递归，我们需要使用“累加器”或“累乘器”来保存中间状态。
# 就以阶乘为例，我们希望在递归过程中将已计算的部分保存下来，作为参数传递给下次调用。
# n×(n−1)×(n−2)×...×1。
# 我们可以把已计算的乘积（初始设为 1）传递给下一层调用。
# 改造后的尾递归函数如下：
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
"""调用 fact(5) 的执行过程为：
fact(5) 调用 fact_iter(5, 1)
在 fact_iter(5, 1) 中：
判断 num 是否等于 1（否）。
调用 fact_iter(4, 5 * 1)，即 fact_iter(4, 5).
在 fact_iter(4, 5) 中：
调用 fact_iter(3, 4 * 5)，即 fact_iter(3, 20).
在 fact_iter(3, 20) 中：
调用 fact_iter(2, 3 * 20)，即 fact_iter(2, 60).
在 fact_iter(2, 60) 中：
调用 fact_iter(1, 2 * 60)，即 fact_iter(1, 120).
在 fact_iter(1, 120) 中：
因为 num == 1，直接返回 120.
这样，通过尾递归的方式，我们在每次递归调用时都没有保留额外的状态，新调用只占用同一个栈帧，从而避免了栈溢出问题。
"""
#尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。
#遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。

#汉诺塔问题
def move(n, a, b, c):
    """
    将 n 个盘子从柱子 a 移动到柱子 c，借助柱子 b。
    
    参数:
      n: 盘子的数量。当 n == 1 时，直接将盘子从 a 移动到 c。
      a: 起始柱子（例如 'A'）
      b: 辅助柱子（例如 'B'）
      c: 目标柱子（例如 'C'）
      
    算法思路：
      - 如果只有1个盘子，直接将它从起始柱子 a 移动到目标柱子 c。
      - 如果有 n 个盘子：
          1. 先将上面的 n-1 个盘子从 a 移动到辅助柱子 b，此时借助目标柱子 c。
          2. 将第 n 个（最大的）盘子从 a 移动到 c。
          3. 最后将那 n-1 个盘子从 b 移动到 c，此时借助起始柱子 a。
    """
    if n == 1:
        # 当只有1个盘子时，直接打印移动步骤
        print("Move disk 1 from", a, "to", c)
    else:
        # 第一步：将前 n-1 个盘子从 a 移到 b，借助 c
        move(n - 1, a, c, b)
        # 第二步：将最大的盘子从 a 移到 c
        print("Move disk", n, "from", a, "to", c)
        # 第三步：将那 n-1 个盘子从 b 移到 c，借助 a
        move(n - 1, b, a, c)

# 调用示例：将3个盘子从柱子 A 移动到柱子 C，借助柱子 B
move(4, 'A', 'B', 'C')
